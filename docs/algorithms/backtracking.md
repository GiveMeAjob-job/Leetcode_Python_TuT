
---

| Status | LeetCode# |  Title                  | Thought Process                                                                                                                                                                                                |
|:-----:|:------------:|:--------------------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|  [ ]  | 46           | Permutations                    | Backtracking to generate all permutations by swapping or building recursively (choose an element, mark it used, recurse).                                                                                      |
|  [ ]  | 47           | Permutations II                 | Similar to #46 but handle duplicates by skipping over repeated elements when generating permutations.                                                                                                          |
|  [ ]  | 78           | Subsets                         | For each element, we can either include it or not include it in the current subset. Recursively build all subsets.                                                                                             |
|  [ ]  | 90           | Subsets II                      | Similar to #78 but handle duplicates by skipping over repeated elements at the same recursion depth.                                                                                                           |
|   ✅    | 77           | Combinations                    | Standard backtracking template: choose or skip numbers to build combinations of length k from range [1..n].                                                                                                    |
|   ✅   | 39           | Combination Sum                 | Pick numbers (with repetition allowed) that sum to target. Backtrack by subtracting the chosen number from target.                                                                                             |
|   ✅   | 40           | Combination Sum II              | Similar to #39 but each candidate can be used at most once. Also handle duplicates by skipping over repeated elements in the same recursion level.                                                             |
|   ✅   | 216          | Combination Sum III             | Choose k distinct numbers in [1..9] that sum to target. Very similar approach to #39/#40, but restricted range and distinct usage.                                                                             |
|   ✅   | 22           | Generate Parentheses            | Backtracking with constraints: track how many '(' and ')' can still be used. Only add ')' if there are more '(' used than ')' in the current path.                                                             |
|  [ ]  | 51           | N-Queens                        | Place queens row by row, check column/conflict diagonals using sets or arrays to avoid collisions.                                                                                                             |
|  [ ]  | 52           | N-Queens II                     | Same approach as #51 but only return the count of solutions.                                                                                                                                                   |
|  [ ]  | 131          | Palindrome Partitioning         | For each valid palindrome substring, recurse on the remaining substring. Accumulate partitions until the entire string is exhausted.                                                                           |
|  [ ]  | 93           | Restore IP Addresses            | Build valid IP segments (0–255, no leading zeros except "0"), track how many segments used. If 4 segments are used and we reach the end of the string, record the valid IP.                                    |
|  [ ]  | 79           | Word Search                     | Perform DFS/backtracking on the board, mark visited cells to avoid reuse in the same path. Restore the state after each recursive call.                                                                        |
|  [ ]  | 301          | Remove Invalid Parentheses      | Backtracking to try removing minimal parentheses. Track counts of left/right parentheses to remove. Prune duplicates with a set or careful skipping.                                                           |
|  [ ]  | 698          | Partition to K Equal Sum Subsets | Backtracking with an array of used/unused elements. Try filling each “bucket” of size `targetSum`. If a bucket’s partial sum is reached, move to the next bucket.                                              |

---
