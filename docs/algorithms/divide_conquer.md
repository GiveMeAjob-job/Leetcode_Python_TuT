
---

| Status |     LeetCode#     | Title                                      | Thought Process                                                                                                                                                                                                                                        |
|:------:|:--------:|:-------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|  [ ]   |    50    | Pow(x, n)                                  | Fast exponentiation by squaring. If `n` is even, `x^n = (x^(n/2))^2`; if odd, `x^n = x * (x^(n-1))`. Consider negative n for 1/x^(-n).                                                                                                                 |
|  [ ]   |    53    | Maximum Subarray                           | Divide the array into two halves. Max subarray is either in the left half, right half, or crosses the midpoint. Combine results. (Though Kadane’s is simpler, this is the classic divide & conquer approach.)                                          |
|  [ ]   |   169    | Majority Element                           | Split array into two halves, recursively find majority in each half, then combine results. If one side’s candidate is truly majority overall, it must appear more than half in the entire array.                                                       |
|  [ ]   |   240    | Search a 2D Matrix II                      | Although there’s a well-known “top-right” linear approach, you can also do a divide & conquer: split matrix by a pivot cell (center), eliminate rows/columns, recursively search sub-parts. Not as common but still possible.                          |
|  [ ]   |   241    | Different Ways to Add Parentheses          | For each operator, split the expression into left and right parts, recursively compute all possible results for each side, then combine. Essentially a divide & conquer on expression.                                                                 |
|  [ ]   |   315    | Count of Smaller Numbers After Self        | Use a modified **merge sort** to count how many elements from the right subarray get placed before an element from the left subarray, indicating “smaller numbers after.”                                                                              |
|  [ ]   |   327    | Count of Range Sum                         | Again, a **merge sort** based approach. Maintain a prefix sum array, then for each prefix sum, search how many sums fall within `[prefixSum[i] - upper, prefixSum[i] - lower]`. Done via sorting & mergesort-based counting.                           |
|  [ ]   |   493    | Reverse Pairs                              | Similar to #315, but counting conditions like `nums[i] > 2*nums[j]`. Use a mergesort-based method to count during the merge step.                                                                                                                      |
|  [ ]   |   218    | The Skyline Problem                        | Classic **divide & conquer** approach: split buildings into left half and right half, recursively solve, then merge the two skylines. (Though a sweep-line approach is also common, the D&C version is a classic demonstration of the algorithm.)      |
|  [ ]   |    23    | Merge k Sorted Lists                       | One method is to pairwise merge lists in a divide & conquer manner: merge lists in pairs (like mergesort). Alternatively, a min-heap approach is more popular, but D&C is also valid.                                                                  |
|  [ ]   |   108    | Convert Sorted Array to Binary Search Tree | Divide array around the mid to build the root, then recursively build left and right subtrees. Perfectly demonstrates dividing an array into subproblems.                                                                                              |
|  [ ]   |   932    | Beautiful Array                            | A known constructive approach uses divide & conquer logic: build from `[1]` recursively by “odd/even” pattern to ensure no arithmetic progression of length 3.                                                                                         |

---
