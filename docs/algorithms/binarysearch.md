
---

| Status | LeetCode#| Title                                                   | Thought Process                                                                                                                                                                  |
|:------:|:-----------:|:--------------------------------------------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|  [ ]   |     704     | Binary Search                                           | The classic binary search. Repeatedly compare `target` with the middle element and narrow down the search space (left or right half).                                            |
|  [ ]   |     69      | Sqrt(x)                                                 | Use binary search to guess the sqrt. If `mid*mid > x`, move to left; otherwise move to right.                                                                                    |
|  [ ]   |     374     | Guess Number Higher or Lower                            | Same binary search pattern. Use the provided guess API to compare, and adjust the search boundaries accordingly.                                                                 |
|  [ ]   |     278     | First Bad Version                                       | Standard binary search. Each time check `mid`, if it's bad, search left side; if not, search right side.                                                                         |
|  [ ]   |     367     | Valid Perfect Square                                    | Check if a number is a perfect square by applying binary search on possible `mid`. Compare `mid*mid` with `num`.                                                                 |
|  [ ]   |     33      | Search in Rotated Sorted Array                          | Find which part of the rotated array is sorted. Decide whether to move left or right based on whether `target` lies in the sorted half.                                          |
|  [ ]   |     81      | Search in Rotated Sorted Array II                       | Similar to #33 but with duplicates. Additional checks for duplicates on the boundaries to reduce search space.                                                                   |
|  [ ]   |     153     | Find Minimum in Rotated Sorted Array                    | Pivot-based binary search. Compare `mid` with `right` to decide which half to search for the minimum.                                                                            |
|  [ ]   |     154     | Find Minimum in Rotated Sorted Array II                 | Similar to #153 but with duplicates. If `nums[mid] == nums[right]`, reduce the boundary (e.g. `right--`) carefully to avoid missing the pivot.                                   |
|  [ ]   |     34      | Find First and Last Position of Element in Sorted Array | Use binary search to find the first occurrence (left boundary) and second binary search for the last occurrence (right boundary).                                                |
|  [ ]   |     744     | Find Smallest Letter Greater Than Target                | Binary search to find the smallest letter that is strictly greater than the target.                                                                                              |
|  [ ]   |     658     | Find K Closest Elements                                 | Either use binary search to find the closest element, then expand two pointers, or do a binary search on the “start index” in the array and refine to get k closest.             |
|  [ ]   |     240     | Search a 2D Matrix II                                   | Although there’s a 2D approach (start from top-right corner), you can also do repeated binary search on each row or each column for a certain complexity.                        |
|  [ ]   |     74      | Search a 2D Matrix                                      | Flatten the 2D matrix conceptually. Treat it as a 1D sorted list and do binary search (row/column calculation by indices).                                                       |
|  [ ]   |     875     | Koko Eating Bananas                                     | Binary search on `eating_speed`. For each speed, calculate total hours needed. If hours ≤ H, we can try a smaller speed; otherwise, increase speed.                              |
|  [ ]   |    1011     | Capacity to Ship Packages Within D Days                 | Binary search on the “capacity.” Check if we can ship all packages within D days given a certain capacity. If yes, lower the capacity; otherwise, increase it.                   |
|  [ ]   |     162     | Find Peak Element                                       | Binary search by comparing `nums[mid]` and `nums[mid+1]`. If `nums[mid] < nums[mid+1]`, a peak must be on the right side; otherwise it’s on the left side.                       |
|  [ ]   |     852     | Peak Index in a Mountain Array                          | Similar to #162, but strictly a “mountain array.” Compare middle with next element to decide which side the peak is on.                                                          |
|  [ ]   |     410     | Split Array Largest Sum                                 | Binary search on the answer (the max subarray sum). For a given limit, check if the array can be split into ≤ m subarrays satisfying that limit.                                 |
|  [ ]   |    1095     | Find in Mountain Array                                  | First, binary search to find the peak. Then perform binary searches (ascending part + descending part) to find the target.                                                       |
|        |      4      |                       |              |

---
