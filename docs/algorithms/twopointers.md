
---

| Status | LeetCode# | Title                                          | Thought Process                                                                                                                                             |
|:------:|:---------:|:-----------------------------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|   ✅    |    125    | Valid Palindrome                               | Use two pointers from both ends, compare characters (ignoring non-alphanumeric & case). If mismatch, return false; if all match, return true.                                  |
|  [ ]   |    344    | Reverse String                                 | Two pointers from front and back, swap characters until they meet in the middle.                                                                                                |
|  [ ]   |    345    | Reverse Vowels of a String                     | Similar to reversing a string, but only swap vowels using two pointers (one from start, one from end).                                                                          |
|   ✅    |    11     | Container With Most Water                      | Two pointers at the ends. Move the pointer with the smaller height inward each time to possibly find a larger area.                                                             |
|   ✅    |    167    | Two Sum II - Input Array Is Sorted             | Two pointers at the ends, compute sum. If sum > target, move right pointer left; if sum < target, move left pointer right.                                                      |
|   ✅    |    15     | 3Sum                                           | Sort the array. For each element, use two pointers to find pairs that sum up to the negative of that element.                                                                   |
|  [ ]   |    16     | 3Sum Closest                                   | Similar to 3Sum. After sorting, fix one number and use two pointers to find a sum closest to target, updating the minimum difference.                                           |
|  [ ]   |    18     | 4Sum                                           | Generalization of 2Sum/3Sum. Often fix two numbers and then two-pointer for the remaining part.                                                                                 |
|  [ ]   |    26     | Remove Duplicates from Sorted Array            | Use two pointers (slow/fast). Fast pointer explores new elements, slow pointer marks the position of the “unique” portion.                                                      |
|  [ ]   |    27     | Remove Element                                 | Similar to #26 approach. Move non-target elements to the front using two pointers.                                                                                              |
|  [ ]   |    80     | Remove Duplicates from Sorted Array II         | Variation on #26 allowing duplicates up to twice. Two pointers keep track of how many times an element has appeared.                                                            |
|  [ ]   |    283    | Move Zeroes                                    | Two pointers. One pointer iterates, the other points to the position where the next non-zero should be placed.                                                                  |
|  [ ]   |    977    | Squares of a Sorted Array                      | Since array is sorted, use two pointers (front & back) to compare absolute values and fill result array from the end.                                                           |
|  [ ]   |    88     | Merge Sorted Array                             | Two pointers from the end of both arrays, fill the nums1 from the back, picking the larger element first.                                                                       |
|  [ ]   |    986    | Interval List Intersections                    | Sort both lists (usually already sorted). Use two pointers for each list to find overlapping intervals. Move the pointer with earlier finishing time.                           |
|  [ ]   |    19     | Remove Nth Node From End of List               | Use two pointers. Move the “fast” pointer n steps ahead, then move both pointers until fast reaches the end. “Slow” will be at the node before the one to remove.              |
|   ✅    |     3     | Longest Substring Without Repeating Characters | Sliding window approach. Use a fast pointer to expand the window, and a slow pointer to shrink the window when encountering duplicates (track with a set or map).               |
|  [ ]   |    209    | Minimum Size Subarray Sum                      | Sliding window. Expand the right pointer until sum ≥ target, then move the left pointer to shrink until sum < target. Keep track of the min window length.                      |
|  [ ]   |    438    | Find All Anagrams in a String                  | Sliding window over `s`. Keep character counts in the window and compare with `p`’s frequency. Move left pointer when window size exceeds the length of `p`.                   |
|  [ ]   |    567    | Permutation in String                          | Sliding window. Maintain a frequency count of characters in the current window. If at any point it matches the frequency count of `s1`, we have a valid permutation.           |
|  [ ]   |    350    | Intersection of Two Arrays II                  | If arrays are sorted, use two pointers to find common elements. If `nums1[i] == nums2[j]`, record it and move both pointers; else move the pointer of the smaller element.      |
|  ✅   |    42     |                       |              |
---
