
---

| Status | LeetCode# | Title                                           | Thought Process                                                                                                                                                                                                                                                                    |
|:------:|:---------:|:------------------------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|  [ ]   |    70     | Climbing Stairs                                 | `dp[i] = dp[i-1] + dp[i-2]`. Number of ways to reach step i is the sum of ways to reach steps i-1 and i-2.                                                                                                                                                                         |
|  [ ]   |    509    | Fibonacci Number                                | Classic DP: `F(n) = F(n-1) + F(n-2)`. Can do bottom-up or top-down memo.                                                                                                                                                                                                           |
|  [ ]   |    746    | Min Cost Climbing Stairs                        | `dp[i]` = cost to reach step i + `min(dp[i-1], dp[i-2])`. Final answer is `min(dp[n-1], dp[n-2])`.                                                                                                                                                                                 |
|  [ ]   |    53     | Maximum Subarray                                | Kadaneâ€™s Algorithm: `dp[i]` = max subarray ending at i. Then `dp[i] = max(nums[i], dp[i-1] + nums[i])`. Global max tracks overall maximum.                                                                                                                                         |
|  [ ]   |    198    | House Robber                                    | `dp[i] = max(dp[i-1], dp[i-2] + nums[i])`. Choose to rob current house plus i-2 or skip current house.                                                                                                                                                                             |
|  [ ]   |    213    | House Robber II                                 | Similar to #198, but the houses form a circle. Solve twice:    1) rob from houses [0..n-2] 2) rob from houses [1..n-1]  Take the max result.                                                                                                                                       |
|  [ ]   |    152    | Maximum Product Subarray                        | Track both `maxProd[i]` and `minProd[i]` (because negative number can flip sign). Update by comparing `nums[i]`, `maxProd[i-1] * nums[i]`, and `minProd[i-1] * nums[i]`.                                                                                                           |
|  [ ]   |    139    | Word Break                                      | `dp[i]` = whether s[0..i-1] can be segmented. For each j < i, if `dp[j]` is true and `s[j..i-1]` in wordDict => `dp[i]` = true.                                                                                                                                                    |
|  [ ]   |    300    | Longest Increasing Subsequence                  | `dp[i]` = length of the LIS ending at i. For each j < i, if `nums[j] < nums[i]`, then `dp[i] = max(dp[i], dp[j] + 1)`.                                                                                                                                                             |
|  [ ]   |    322    | Coin Change                                     | `dp[x]` = min number of coins to make amount x. Initialize `dp[0] = 0`, else large. For each coin, if `x >= coin`, `dp[x] = min(dp[x], dp[x - coin] + 1)`.                                                                                                                         |
|  [ ]   |    343    | Integer Break                                   | Break n into at least two positive integers to get the maximum product. `dp[i] = max(dp[i], j*(i-j), j*dp[i-j])` for all j.                                                                                                                                                        |
|  [ ]   |    377    | Combination Sum IV                              | `dp[x]` = number of ways to form sum x. For each coin/num, if `x >= num`, `dp[x] += dp[x - num]`. Order matters if not specified otherwise.                                                                                                                                        |
|  [ ]   |     5     | Longest Palindromic Substring                   | `dp[i][j]` = whether substring s[i..j] is palindrome. True if `s[i] == s[j]` and `dp[i+1][j-1]` is true (with base cases for length 1 or 2).                                                                                                                                       |
|  [ ]   |    131    | Palindrome Partitioning                         | Backtracking + DP (to quickly check palindrome). Or use `dp[i]` to track partitions up to i. Typically combined with recursion to build all solutions.                                                                                                                             |
|  [ ]   |    62     | Unique Paths                                    | `dp[i][j]` = number of ways to get to cell (i, j). Typically `dp[i][j] = dp[i-1][j] + dp[i][j-1]` with boundary conditions.                                                                                                                                                        |
|  [ ]   |    63     | Unique Paths II                                 | Similar to #62, but with obstacles. If obstacle at (i,j), then `dp[i][j] = 0`. Else `dp[i][j] = dp[i-1][j] + dp[i][j-1]`.                                                                                                                                                          |
|  [ ]   |    64     | Minimum Path Sum                                | `dp[i][j]` = grid[i][j] + min(dp[i-1][j], dp[i][j-1]). Start from top-left, boundaries handled carefully.                                                                                                                                                                          |
|  [ ]   |    72     | Edit Distance                                   | `dp[i][j]` = distance between word1[0..i-1] and word2[0..j-1]. If `word1[i-1] == word2[j-1]`, `dp[i][j] = dp[i-1][j-1]`; else take min of replace, insert, delete + 1.                                                                                                             |
|  [ ]   |   1143    | Longest Common Subsequence                      | `dp[i][j]` = 1 + `dp[i-1][j-1]` if `text1[i-1] == text2[j-1]`, else `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`.                                                                                                                                                                      |
|  [ ]   |    494    | Target Sum                                      | You can see it as counting subsets with a certain sum (transform to subset sum). Or do a top-down memo with choices of +num[i] or -num[i].                                                                                                                                         |

---

