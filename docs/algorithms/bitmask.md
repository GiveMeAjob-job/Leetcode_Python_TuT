
在完成对应题目后，可将 `[ ]` 改为 `[x]`。

---

| Status |     LeetCode#     | Title                                                          | Thought Process                                                                                                                                                                                                                                            |
|:----:|:--------:|:---------------------------------------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [ ]  |    78    | Subsets                                                        | Use a bitmask from `0` to `2^n - 1`. Each bit represents whether the corresponding element is included (1) or not (0).                                                                                                                                     |
| [ ]  |    89    | Gray Code                                                      | Generate a sequence of `0..2^n-1` with consecutive values differing by 1 bit. Recursive or bitwise formula approach: `G(i) = i ^ (i >> 1)`.                                                                                                                |
| [ ]  |   136    | Single Number                                                  | XOR of all elements leaves the unique number, since `a ^ a = 0` and `a ^ 0 = a`.                                                                                                                                                                           |
| [ ]  |   137    | Single Number II                                               | Each bit position’s sum mod 3 identifies the unique element. Alternatively, maintain two bitmasks (`ones`, `twos`) to track bits appearing once or twice.                                                                                                  |
| [ ]  |   190    | Reverse Bits                                                   | Reverse the 32-bit binary representation of an unsigned integer. Shift + bit manipulation approach.                                                                                                                                                        |
| [ ]  |   191    | Number of 1 Bits                                               | Count set bits in an integer. Common methods: repeatedly do `n & (n-1)` to drop the lowest set bit, or shift & count.                                                                                                                                      |
| [ ]  |   201    | Bitwise AND of Numbers Range                                   | The common prefix of `m` and `n` in binary form is the result; shift right until `m == n`, then shift back.                                                                                                                                                |
| [ ]  |   260    | Single Number III                                              | Two unique numbers appear once, others appear twice. XOR all => `x = a ^ b`. Then use the rightmost set bit of `x` to partition all numbers into two groups.                                                                                               |
| [ ]  |   318    | Maximum Product of Word Lengths                                | Convert each word into a bitmask representing which letters it has. Two words have no common letters if `(maskA & maskB) == 0`. Precompute word masks, then compare to find max product of lengths.                                                        |
| [ ]  |   338    | Counting Bits                                                  | `dp[i] = dp[i >> 1] + (i & 1)` or use built-in bit-count functions. Each index’s bit count relates to half of it plus possibly 1.                                                                                                                          |
| [ ]  |   461    | Hamming Distance                                               | Count differing bits between two integers `x` and `y`. Do `x ^ y` and then count set bits.                                                                                                                                                                 |
| [ ]  |   477    | Total Hamming Distance                                         | For each bit position, count how many numbers have that bit set vs. unset. The contribution to total is `countSet * countUnset` for that bit.                                                                                                              |
| [ ]  |   473    | Matchsticks to Square                                          | Backtracking with bitmask DP: we want to partition sticks into 4 subsets each summing to `side`. Keep track of used sticks in a bitmask; memo on (mask, currentSum).                                                                                       |
| [ ]  |   698    | Partition to K Equal Sum Subsets                               | Similar to #473 but generalized to k subsets. Use bitmask to track which elements are used. Then DFS + memo to see if we can fill each “bucket.”                                                                                                           |
| [ ]  |   847    | Shortest Path Visiting All Nodes                               | State is `(currentNode, visitedMask)`. Use BFS or Dijkstra-like approach to find the shortest route that visits all nodes (`visitedMask == (1 << n) - 1`).                                                                                                 |
| [ ]  |   1239   | Maximum Length of a Concatenated String with Unique Characters | Convert each string to a bitmask of used letters (if it has duplicates, discard). Then do backtracking or DFS with these masks, checking `(maskA & maskB) == 0` to ensure uniqueness. Keep track of max total length.                                      |

---
