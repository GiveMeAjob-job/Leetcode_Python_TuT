
---

| Status | LeetCode#|  Title                                           | Thought Process                                                                                                                                                                  |
|:------:|:------------:|:--------------------------------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|  [ ]   | 94           | Binary Tree Inorder Traversal                           | Recursively (left-root-right) or iteratively with a stack.                                                                                                                                         |
|  [ ]   | 144          | Binary Tree Preorder Traversal                          | Recursively (root-left-right) or iteratively with a stack.                                                                                                                                         |
|  [ ]   | 145          | Binary Tree Postorder Traversal                         | Recursively (left-right-root) or iteratively with a stack (careful with the order).                                                                                                                 |
|  [ ]   | 102          | Binary Tree Level Order Traversal                       | Use a queue (BFS) to traverse level by level.                                                                                                                                                      |
|  [ ]   | 103          | Binary Tree Zigzag Level Order Traversal               | Similar to level order but reverse the order of nodes every other level. A deque or toggling a flag can help.                                                                                       |
|  [ ]   | 98           | Validate Binary Search Tree                             | Use an inorder traversal or recursively check if `root->val` is between (min, max). Update bounds when descending.                                                                                 |
|  [ ]   | 101          | Symmetric Tree                                         | Check if left subtree is a mirror of right subtree. Either recursively or iteratively (queue/stack).                                                                                                |
|  [ ]   | 104          | Maximum Depth of Binary Tree                            | Simple DFS, depth = 1 + max(depth of left, depth of right).                                                                                                                                       |
|  [ ]   | 110          | Balanced Binary Tree                                   | DFS returning tree height; if any subtree difference > 1, return -1 or a sentinel to indicate imbalance.                                                                                           |
|  [ ]   | 112          | Path Sum                                               | DFS, subtract node value from sum and check if you reach a leaf and the resulting sum is 0.                                                                                                        |
|  [ ]   | 113          | Path Sum II                                            | Similar to #112, but store the path along the way. Backtrack when returning up the tree.                                                                                                           |
|  [ ]   | 124          | Binary Tree Maximum Path Sum                           | Post-order DFS. For each node, compute one-branch max path. Update global max with possible “node + left + right”.                                                                                 |
|  [ ]   | 105          | Construct Binary Tree from Preorder and Inorder Traversal | Preorder’s first element is root. Find root in inorder to separate left/right subtrees. Recursively build subtrees.                                                                                |
|  [ ]   | 106          | Construct Binary Tree from Inorder and Postorder Traversal | Postorder’s last element is root. Find root in inorder to split. Recursively build.                                                                                                               |
|  [ ]   | 116          | Populating Next Right Pointers in Each Node            | For a perfect binary tree, use level order or connect children in pairs (root->left->next = root->right). Then connect sibling subtrees.                                                                 |
|  [ ]   | 117          | Populating Next Right Pointers in Each Node II         | General tree (not necessarily perfect). Use BFS with a queue or a dummy head approach to connect next pointers level by level.                                                                     |
|  [ ]   | 236          | Lowest Common Ancestor of a Binary Tree                | If one subtree has p and q, descend that subtree. Otherwise, LCA is the node splitting that search or it is one of the subtrees. DFS approach.                                                     |
|  [ ]   | 230          | Kth Smallest Element in a BST                          | Inorder traversal of BST is sorted. Keep a count; when the count = k, the current node is the answer. Alternatively, you can use a stack or a min-heap approach.                                   |
|  [ ]   | 297          | Serialize and Deserialize Binary Tree                  | Use BFS or DFS to serialize. For deserialize, read the data and reconstruct the tree node by node.                                                                                                  |
|  [ ]   | 450          | Delete Node in a BST                                  | Standard BST deletion. If the node has two children, replace it with successor/predecessor, then delete that successor/predecessor node.                                                                 |
|  [ ]   | 538          | Convert BST to Greater Tree                            | Reverse inorder (right-root-left) to accumulate running sum. Assign current node value += sum so far, then update sum.                                                                             |
|  [ ]   | 652          | Find Duplicate Subtrees                                | Serialize each subtree (e.g., postorder) or use a hashing approach. Store counts in a map. If the same serialized form appears more than once, it’s a duplicate.                                   |

---

