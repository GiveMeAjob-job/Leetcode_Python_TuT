
---

| Status | LeetCode# | Title                                       | Thought Process                                                                                                                                                                |
|:------:|:------------:|:--------------------------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|  [ ]   | 206          | Reverse Linked List                         | Iterative or recursive: change `head->next` pointers to reverse direction. Keep track of `prev` node as you iterate.                                                                              |
|  [ ]   | 92           | Reverse Linked List II                      | Reverse a sublist from position m to n. Use pointers to find the sublist's start & end, then reverse that portion.                                                                               |
|  [ ]   | 21           | Merge Two Sorted Lists                      | Create a dummy head, use two pointers to compare the heads of both lists, append the smaller node to the merged list, move forward until one list is empty.                                       |
|  [ ]   | 23           | Merge k Sorted Lists                        | Can merge iteratively two by two, or use a **min-heap** to always pop the smallest node among the k lists’ heads, then push the popped node's next.                                               |
|  [ ]   | 19           | Remove Nth Node From End of List            | Use two pointers: move `fast` n steps first, then move both `fast` and `slow` until `fast` is at the end. Remove `slow->next`.                                                                    |
|  [ ]   | 2            | Add Two Numbers                             | Simulate addition with carry. Traverse both lists, sum the corresponding digits + carry, and create new nodes for the result.                                                                      |
|  [ ]   | 86           | Partition List                              | Split the list into two lists: one with nodes < x, another with nodes >= x, then concatenate them.                                                                                                |
|  [ ]   | 141          | Linked List Cycle                           | Use **Floyd’s Tortoise and Hare**: move slow by 1 step and fast by 2 steps. If they meet, there's a cycle; if fast (or fast->next) is NULL, no cycle.                                            |
|  [ ]   | 142          | Linked List Cycle II                        | After detecting a cycle with #141 approach, reset one pointer to head, move both pointers at 1 step each. The point where they meet is the cycle's start.                                         |
|  [ ]   | 160          | Intersection of Two Linked Lists            | Traverse both lists to find lengths, then align start points (if one is longer, skip the difference). Move both pointers simultaneously until they meet or reach the end.                          |
|  [ ]   | 876          | Middle of the Linked List                   | Use slow & fast pointers. Fast pointer moves 2 steps each time, slow pointer 1 step. When fast reaches end, slow is at the middle.                                                                |
|  [ ]   | 83           | Remove Duplicates from Sorted List          | Traverse the sorted list, compare current node’s value with `next`. If equal, skip the `next` node; else move on.                                                                                 |
|  [ ]   | 82           | Remove Duplicates from Sorted List II       | Compared to #83, remove **all** occurrences of duplicates. Use a dummy head, track when a sequence of duplicates begins, skip them entirely.                                                     |
|  [ ]   | 61           | Rotate List                                 | If we rotate k times, effectively the last k nodes move to the front. Compute list length to find effective rotations (k mod length). Re-link the tail to head, then find the new tail to break. |
|  [ ]   | 143          | Reorder List                                | Split the list into two halves, reverse the second half, then merge the two lists in alternating fashion.                                                                                        |
|  [ ]   | 328          | Odd Even Linked List                        | Re-link nodes so that all odd-indexed nodes appear first, followed by even-indexed nodes (1-based). Keep separate odd/even lists and merge at the end.                                            |
|  [ ]   | 138          | Copy List with Random Pointer               | Often a three-step solution: (1) clone each node and insert the clone right after the original node, (2) link random pointers, (3) separate the two interleaved lists.                             |
|  [ ]   | 708          | Insert into a Cyclic Sorted List            | Traverse the cycle. Find the correct place to insert the new node (where `current->val <= x <= current->next->val`), or insert if it’s the turning point from max to min. Handle edge cases.      |
|  [ ]   | 430          | Flatten a Multilevel Doubly Linked List     | Traverse with a stack/DFS approach. If a node has a child, push the current node’s next into stack, link child as next, clear the child pointer, and continue.                                    |
|  [ ]   | 234          | Palindrome Linked List                      | To check if a linked list is a palindrome: find the middle, reverse the second half, then compare first half and reversed second half node by node.                                              |

---

